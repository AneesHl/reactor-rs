//-- Generated by LFC @ 2021/07/25 16:40:36 --//
#![allow(unused)]

use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
use ::reactor_rt::Offset::{After, Asap};
use std::sync::{Arc, Mutex};



// todo link to source
pub struct Minimal {

}

#[warn(unused)]
impl Minimal {

    // --- reaction(startup) {= ... =}
    fn react_0(&mut self, 
               #[allow(unused)] ctx: &mut ::reactor_rt::LogicalCtx,
               #[allow(unused)] params: &MinimalParams,
    ) {
        println!("Hello World.");
    }

}

/// Parameters for the construction of a [Minimal]
#[derive(Clone)]
pub struct MinimalParams {

}


//------------------------//


pub struct MinimalDispatcher {
    _id: ::reactor_rt::ReactorId,
    _impl: Minimal,
    _params: MinimalParams,
    _startup_reactions: ::reactor_rt::ReactionSet,
    _shutdown_reactions: ::reactor_rt::ReactionSet,

}


reaction_ids!(
  pub enum MinimalReactions {R0 = 0,}
);

impl MinimalDispatcher {
    #[inline]
    fn user_assemble(_id: ::reactor_rt::ReactorId, args: MinimalParams) -> Self {
        let MinimalParams {  } = args.clone();
        Self {
            _id,
            _params: args,
            _startup_reactions: Default::default(),
            _shutdown_reactions: Default::default(),
            _impl: Minimal {

            },

        }
    }
}

use ::reactor_rt::*; // after this point there's no user-written code

impl ::reactor_rt::ReactorDispatcher for MinimalDispatcher {
    type ReactionId = MinimalReactions;
    type Wrapped = Minimal;
    type Params = MinimalParams;

    fn assemble(args: Self::Params, assembler: &mut AssemblyCtx) -> Arc<Mutex<Self>> {
        // children reactors   


        // assemble self
        let this_reactor = assembler.get_next_id();
        let mut _self = Arc::new(Mutex::new(Self::user_assemble(this_reactor, args)));

        let react_0 = new_reaction!(this_reactor, _self, R0);

        {
            let mut statemut = _self.lock().unwrap();
            
            statemut._startup_reactions = vec![react_0.clone()];
            statemut._shutdown_reactions = vec![];


        }
        {
            // Declare connections
        }


       _self
    }

    #[inline]
    fn react(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: Self::ReactionId) {
        match rid {
            MinimalReactions::R0 => {
                self._impl.react_0(ctx, &self._params)
            }
        }
    }
}


impl ::reactor_rt::ErasedReactorDispatcher for MinimalDispatcher {

    fn id(&self) -> ReactorId {
        self._id
    }

    fn react_erased(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: u32) {
        let rid = <MinimalReactions as int_enum::IntEnum>::from_int(rid).unwrap();
        self.react(ctx, rid)
    }

    fn cleanup_tag(&mut self, ctx: ::reactor_rt::LogicalCtx) {
        // todo
    }
    
    fn enqueue_startup(&self, ctx: &mut StartupCtx) {


        ctx.enqueue(&self._startup_reactions);
    }

    fn enqueue_shutdown(&self, ctx: &mut StartupCtx) {
        ctx.enqueue(&self._shutdown_reactions);
    }

}