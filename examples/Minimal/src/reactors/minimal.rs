//-- Generated by LFC @ 2021/07/23 16:06:15 --//
#![allow(unused)]

use std::sync::{Arc, Mutex};
use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
use ::reactor_rt::Offset::{After, Asap};


// todo link to source
pub struct Minimal {}

#[warn(unused)]
impl Minimal {
    // --- reaction(startup) {= ... =}
    fn react_0(&mut self,
               #[allow(unused)] ctx: &mut ::reactor_rt::LogicalCtx,
               #[allow(unused)] params: &MinimalParams,
    ) {
        println!("Hello World.");
    }
}

/// Parameters for the construction of a [Minimal]
#[derive(Clone)]
pub struct MinimalParams {}


//------------------------//


pub struct MinimalDispatcher {
    // state struct
    _impl: Minimal,
    // ctor parameters
    _params: MinimalParams,
    // other components
}


reaction_ids!(
  pub enum MinimalReactions {R0=0}
);

impl ::reactor_rt::ReactorDispatcher for MinimalDispatcher {
    type ReactionId = MinimalReactions;
    type Wrapped = Minimal;
    type Params = MinimalParams;

    #[inline]
    fn assemble(params: Self::Params) -> Self {
        let MinimalParams {} = params.clone();
        Self {
            _params: params,
            _impl: Minimal {},

        }
    }

    fn react(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: Self::ReactionId) {
        match rid {
            MinimalReactions::R0 => {
                self._impl.react_0(ctx, &self._params)
            }
        }
    }
}

impl ErasedReactorDispatcher for MinimalDispatcher {
    fn react_erased(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: u32) {
        let rid = <MinimalReactions as int_enum::IntEnum>::from_int(rid).unwrap();
        self.react(ctx, rid)
    }

    fn cleanup_tag(&mut self, ctx: ::reactor_rt::LogicalCtx) {
        // todo
    }
}


//------------------------//

use ::reactor_rt::*; // after this point there's no user-written code


pub struct MinimalAssembler {
    pub(in super) _rstate: Arc<Mutex<MinimalDispatcher>>,
    // nested reactors

    // self reactions
    react_0: Arc<::reactor_rt::ReactionInvoker>,
}

impl ReactorAssembler for MinimalAssembler {
    type RState = MinimalDispatcher;

    #[inline]
    fn start(&mut self, startup_ctx: &mut StartupCtx) {
        if true {
            // Startup this reactor
            let dispatcher = &mut self._rstate.lock().unwrap();
            let ctx = &mut startup_ctx.logical_ctx();

            // Startup timers

            // Execute reactions triggered by startup in order. FIXME use enqueue
            dispatcher.react(ctx, MinimalReactions::R0);
        }
        // Startup children reactors
    }

    fn assemble(
        ctx: &mut AssemblyCtx<Self>,
        args: <Self::RState as ReactorDispatcher>::Params,
    ) -> Self {
        let mut _rstate = Arc::new(Mutex::new(Self::RState::assemble(args)));
        let this_reactor = ctx.get_id();
        let mut reaction_id = 0;

        let react_0 = new_reaction!(this_reactor, reaction_id, _rstate, R0);


        if false {
            // Declare local dependencies
            let mut statemut = _rstate.lock().unwrap();
        }
        {
            // Declare connections
        }
        Self {
            _rstate,

            react_0,
        }
    }
}
