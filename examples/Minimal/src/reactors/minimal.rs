//-- Generated by LFC @ 2021/07/25 13:32:31 --//
#![allow(unused)]

use std::sync::{Arc, Mutex};
use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
use ::reactor_rt::Offset::{After, Asap};



// todo link to source
pub struct Minimal {

}

#[warn(unused)]
impl Minimal {

    // --- reaction(startup) {= ... =}
    fn react_0(&mut self, 
               #[allow(unused)] ctx: &mut ::reactor_rt::LogicalCtx,
               #[allow(unused)] params: &MinimalParams,
    ) {
        println!("Hello World.");
    }

}

/// Parameters for the construction of a [Minimal]
#[derive(Clone)]
pub struct MinimalParams {

}


//------------------------//


pub struct MinimalDispatcher {
    // state struct
    _impl: Minimal,
    // ctor parameters
    _params: MinimalParams,
    // other components

}


reaction_ids!(
  pub enum MinimalReactions {R0 = 0}
);

impl ::reactor_rt::ReactorDispatcher for MinimalDispatcher {
    type ReactionId = MinimalReactions;
    type Wrapped = Minimal;
    type Params = MinimalParams;

    #[inline]
    fn assemble(params: Self::Params) -> Self {
        let MinimalParams {  } = params.clone();
        Self {
            _params: params,
            _impl: Minimal {

            },

        }
    }

    #[inline]
    fn react(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: Self::ReactionId) {
        match rid {
            MinimalReactions::R0 => {
                self._impl.react_0(ctx, &self._params)
            }
        }
    }
}

impl ::reactor_rt::ErasedReactorDispatcher for MinimalDispatcher {

    fn react_erased(&mut self, ctx: &mut ::reactor_rt::LogicalCtx, rid: u32) {
        let rid = <MinimalReactions as int_enum::IntEnum>::from_int(rid).unwrap();
        self.react(ctx, rid)
    }

    fn cleanup_tag(&mut self, ctx: ::reactor_rt::LogicalCtx) {
        // todo
    }
}

//------------------------//

use ::reactor_rt::*; // after this point there's no user-written code


pub struct MinimalAssembler {
    pub(in super) _rstate: Arc<Mutex<MinimalDispatcher>>,
    // nested reactors

    // self reactions
    react_0: Arc<::reactor_rt::ReactionInvoker>,
    // timers

}

impl ReactorAssembler for MinimalAssembler {
    type RState = MinimalDispatcher;
    
    fn enqueue_shutdown(&mut self, ctx: &mut StartupCtx) {
        // todo
    }

    fn enqueue_startup(&mut self, startup_ctx: &mut StartupCtx) {

        startup_ctx.enqueue(vec![
            self.react_0.clone()
        ]);
        // Startup children reactors

    }

    fn assemble(
       ctx: &mut AssemblyCtx<Self>,
       args: <Self::RState as ReactorDispatcher>::Params
    ) -> Self {
        let mut _rstate = Arc::new(Mutex::new(Self::RState::assemble(args)));
        let this_reactor = ctx.get_current_id();

        let react_0 = new_reaction!(this_reactor, _rstate, R0);



        if false {
            // Declare local dependencies
            let mut statemut = _rstate.lock().unwrap();


        }
        {
            // Declare connections
        }
        Self {
            _rstate,

            react_0,
        }
    }
}
