target Rust {
    cargo-features: ["cli"],
    cargo-dependencies: {
        termcolor: "1",
        termion: "1",
        rand: "0.8",
    },
    rust-include: "snakes.rs",
    keepalive: true,
};

import KeyboardEvents from "KeyboardEvents.lf";

main reactor Snake(grid_side: usize(32), tempo: u8(2)) {
    preamble {=
        use crate::snakes::*;
        use termion::event::Key;
    =}

    keyboard = new KeyboardEvents();

    /// Triggers a screen refresh, not a timer because we can
    /// shrink the period over time to speed up the game.
    logical action screen_refresh;
    /// The game speed
    state tempo: u8(tempo);

    state snake: CircularSnake ({= CircularSnake::new(grid_side) =});
    state grid: SnakeGrid ({= SnakeGrid::new(grid_side, &snake) =});

    /// Whither the snake is currently looking, changes with arrow key presses
    state cur_heading: Direction ({= Direction::RIGHT =});


    // @label startup
    reaction(startup) -> screen_refresh {=
        // KeyboardEvents makes stdout raw
        paint_on_raw_console(&self.grid);
        ctx.schedule(screen_refresh, After(Duration::from_secs(1)));
    =}

    // @label handle_key_press
    reaction(keyboard.arrow_key_pressed) {=
        // change the current heading, might be overwritten between two frames
        self.cur_heading = match ctx.get(keyboard__arrow_key_pressed).unwrap() {
            Key::Left => Direction::LEFT,
            Key::Right => Direction::RIGHT,
            Key::Up => Direction::UP,
            Key::Down => Direction::DOWN,
            _ => unreachable!(),
        };
    =}

    // @label refresh_screen
    reaction(screen_refresh) {=
        if self.snake.step(self.cur_heading, &mut self.grid) {
            paint_on_raw_console(&self.grid);
        } else {
            // todo game over
        }
    =}

    // @label schedule_next_tick
    reaction(screen_refresh) -> screen_refresh {=
        // select a delay depending on the tempo
        let delay = match self.tempo / 32 {
            0 => Duration::from_millis(400),
            1 => Duration::from_millis(370),
            2 => Duration::from_millis(350),
            // todo
            3 => Duration::from_millis(170),
            4 => Duration::from_millis(150),
            5 => Duration::from_millis(100),
            6 => Duration::from_millis(200),
            7 => Duration::from_millis(200),
            x => unreachable!("unexpected tempo value {} ({} / 32)", x, self.tempo),
        };

        ctx.schedule(screen_refresh, After(delay));
    =}


    preamble {=
        use std::io::{Write, Error, Result, ErrorKind};

        pub fn paint_on_raw_console(grid: &SnakeGrid) {
            use std::io::Write;
            let str = format_for_raw_console(grid).unwrap();
            let stdout = std::io::stdout();
            let mut stdout = stdout.lock();

            // this escape char clears the terminal
            write!(stdout, "\x1B[2J\n\r{}", str).unwrap();
            stdout.flush().unwrap();
        }

        fn format_for_raw_console(grid: &SnakeGrid) -> Result<String> {
            use termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};

            let bufwtr = BufferWriter::stdout(ColorChoice::Always);
            let mut buf = bufwtr.buffer();

            fn print_fence(buf: &mut Buffer, side: usize) -> Result<()> {
                write!(buf, "|")?;
                for _ in 0..side {
                    write!(buf, "-")?;
                }
                write!(buf, "|\n\r")
            }
            
            print_fence(&mut buf, grid.grid_side())?;

            for row in 0..grid.grid_side() {
                write!(&mut buf, "|").unwrap();
                for col in 0..grid.grid_side() {
                    match grid[cell(row, col)] {
                        CellState::SnakeHead => write!(&mut buf, "@")?,
                        CellState::Snake     => write!(&mut buf, "o")?,
                        CellState::Food      => write!(&mut buf, "$")?,
                        CellState::Free      => write!(&mut buf, " ")?,
                    }
                }
                write!(&mut buf, "|\n\r")?;
            }

            print_fence(&mut buf, grid.grid_side())?;

            String::from_utf8(buf.into_inner()).map_err(|e| Error::new(ErrorKind::Other, e))
        }

    =}
}
