target Rust {
    cargo-features: ["cli"],
    cargo-dependencies: {
        termcolor: "1",
        termion: "1",
        rand: "0.8",
    },
    rust-include: "snakes.rs",
    keepalive: true,
};

import KeyboardEvents from "KeyboardEvents.lf";

main reactor Snake(grid_side: usize(32), tempo: u32(2)) {
    preamble {=
        use crate::snakes::*;
        use termion::event::Key;
        use rand::prelude::*;

        const MAX_FOOD_ON_GRID: u32 = 2;
        const MAX_TEMPO: u32 = 16;
    =}

    keyboard = new KeyboardEvents();

    /// Triggers a screen refresh, not a timer because we can
    /// shrink the period over time to speed up the game.
    logical action screen_refresh;
    /// The game speed
    state tempo: u32(tempo);

    /// manually triggered
    logical action manually_add_more_food;
    /// periodic
    timer add_more_food(0, 5 sec);
    state food_on_grid: u32(0);

    state snake: CircularSnake ({= CircularSnake::new(grid_side) =});
    state grid: SnakeGrid ({= SnakeGrid::new(grid_side, &snake) =});

    /// Whither the snake is currently looking, changes with arrow key presses
    state snake_direction: Direction ({= Direction::RIGHT =});


    // @label startup
    reaction(startup) -> screen_refresh {=
        // KeyboardEvents makes stdout raw
        paint_on_raw_console(&self.grid);
        ctx.schedule(screen_refresh, After(Duration::from_secs(1)));
    =}

    // @label handle_key_press
    reaction(keyboard.arrow_key_pressed) {=
        // change the current heading, might be overwritten between two frames
        let new_direction = match ctx.get(keyboard__arrow_key_pressed).unwrap() {
            Key::Left => Direction::LEFT,
            Key::Right => Direction::RIGHT,
            Key::Up => Direction::UP,
            Key::Down => Direction::DOWN,
            _ => unreachable!(),
        };
        // cannot make a 180Â° in one step
        if new_direction != self.snake_direction.opposite() {
            self.snake_direction = new_direction;
        }
    =}

    // @label refresh_screen
    reaction(screen_refresh) -> manually_add_more_food {=
        // snakes don't "step" forward
        match self.snake.slither_forward(self.snake_direction, &mut self.grid) {
            UpdateResult::GameOver => { ctx.request_stop(); return; },
            UpdateResult::FoodEaten => {
                self.food_on_grid -= 1;
                if self.food_on_grid == 0 {
                    ctx.schedule(manually_add_more_food, Asap);
                }
                self.tempo += 1;
            },
            UpdateResult::NothingInParticular => {/* do nothing in particular. */}
        }

        paint_on_raw_console(&self.grid);
    =}

    reaction(manually_add_more_food, add_more_food) {=
        if self.food_on_grid >= MAX_FOOD_ON_GRID {
            return; // there's enough food there
        }
        let mut rng = thread_rng();
        loop {
            let row = rng.gen_range(0..params.grid_side);
            let col = rng.gen_range(0..params.grid_side);
            if self.grid[cell(row, col)] == CellState::Free {
                self.grid[cell(row, col)] = CellState::Food; // next screen update will catch this.
                self.food_on_grid += 1;
                break;
            }
            // otherwise try again
        }
    =}

    // @label schedule_next_tick
    reaction(screen_refresh) -> screen_refresh {=

        // select a delay depending on the tempo
        let millis = 400 - 20 * self.tempo.min(MAX_TEMPO);
        let delay = Duration::from_millis(millis as u64);

        ctx.schedule(screen_refresh, After(delay));
    =}


    preamble {=
        use std::io::{Write, Error, Result, ErrorKind};

        pub fn paint_on_raw_console(grid: &SnakeGrid) {
            use std::io::Write;
            let str = format_for_raw_console(grid).unwrap();
            let stdout = std::io::stdout();
            let mut stdout = stdout.lock();

            // this escape char clears the terminal
            write!(stdout, "\x1B[2J\n\r{}", str).unwrap();
            stdout.flush().unwrap();
        }

        fn format_for_raw_console(grid: &SnakeGrid) -> Result<String> {
            use termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};

            let bufwtr = BufferWriter::stdout(ColorChoice::Always);
            let mut buf = bufwtr.buffer();

            fn print_fence(buf: &mut Buffer, side: usize) -> Result<()> {
                write!(buf, "+")?;
                for _ in 0..side {
                    write!(buf, "~")?;
                }
                write!(buf, "+\n\r")
            }
            
            print_fence(&mut buf, grid.grid_side())?;

            for row in 0..grid.grid_side() {
                write!(&mut buf, "|").unwrap();
                for col in 0..grid.grid_side() {
                    match grid[cell(row, col)] {
                        CellState::SnakeHead => write!(&mut buf, "@")?,
                        CellState::Snake     => write!(&mut buf, "o")?,
                        CellState::Food      => write!(&mut buf, "$")?,
                        CellState::Free      => write!(&mut buf, " ")?,
                    }
                }
                write!(&mut buf, "|\n\r")?;
            }

            print_fence(&mut buf, grid.grid_side())?;

            String::from_utf8(buf.into_inner()).map_err(|e| Error::new(ErrorKind::Other, e))
        }

    =}
}
