target Rust {
    cargo-features: ["cli"],
    cargo-dependencies: {
        termcolor: "1",
        termion: "1",
        rand: "0.8",
    },
    rust-include: "snakes.rs",
    keepalive: true,
};

import KeyboardEvents from "KeyboardEvents.lf";

main reactor Snake(grid_side: usize(32), tempo: u8(2)) {
    preamble {=
        use crate::snakes::*;
        use termion::event::Key;
    =}

    keyboard = new KeyboardEvents();

    /// Triggers a screen refresh, not a timer because we can
    /// shrink the period over time to speed up the game.
    logical action screen_refresh;
    /// The game speed
    state tempo: u8(tempo);

    state snake: CircularSnake ({= CircularSnake::new(grid_side) =});
    state grid: SnakeGrid ({= SnakeGrid::new(grid_side, &snake) =});

    /// Whither the snake is currently looking, changes with arrow key presses
    state cur_heading: Direction ({= Direction::RIGHT =});


    // @label startup
    reaction(startup) -> screen_refresh {=
        // KeyboardEvents makes stdout raw
        paint_on_raw_console(&self.grid);
        ctx.schedule(screen_refresh, After(Duration::from_secs(1)));
    =}

    // @label handle_key_press
    reaction(keyboard.arrow_key_pressed) {=
        // change the current heading, might be overwritten between two frames
        self.cur_heading = match ctx.get(keyboard__arrow_key_pressed).unwrap() {
            Key::Left => Direction::LEFT,
            Key::Right => Direction::RIGHT,
            Key::Up => Direction::UP,
            Key::Down => Direction::DOWN,
            _ => unreachable!(),
        };
    =}

    // @label refresh_screen
    reaction(screen_refresh) {=
        if self.snake.step(self.cur_heading, &mut self.grid) {
            paint_on_raw_console(&self.grid);
        } else {
            // todo game over
        }
    =}

    // @label schedule_next_tick
    reaction(screen_refresh) -> screen_refresh {=
        // select a delay depending on the tempo
        let delay = match self.tempo / 32 {
            b'0' => Duration::from_millis(400),
            b'1' => Duration::from_millis(370),
            b'2' => Duration::from_millis(350),
            // todo
            b'3' => Duration::from_millis(170),
            b'4' => Duration::from_millis(150),
            b'5' => Duration::from_millis(100),
            b'6' => Duration::from_millis(200),
            b'7' => Duration::from_millis(200),
            _ => unreachable!(),
        };

        ctx.schedule(screen_refresh, After(delay));
    =}


    preamble {=

        pub fn paint_on_raw_console(grid: &SnakeGrid) {
            use std::io::Write;
            let str = format_for_raw_console(grid);
            let stdout = std::io::stdout();
            let mut stdout = stdout.lock();

            // this escape char clears the terminal
            write!(stdout, "\x1B[2J{}", str).unwrap();
            stdout.flush().unwrap();
        }

        fn format_for_raw_console(grid: &SnakeGrid) -> String {
            use std::io::Write;
            use termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};

            let bufwtr = BufferWriter::stdout(ColorChoice::Always);
            let mut buf = bufwtr.buffer();

            for _ in 0..grid.grid_side() {
                write!(&mut buf, "-").unwrap();
            }
            write!(&mut buf, "|\n\r").unwrap();

            for row in 0..grid.grid_side() {
                write!(&mut buf, "|").unwrap();
                for col in 0..grid.grid_side() {
                    match grid[cell(row, col)] {
                        CellState::SnakeHead => write!(&mut buf, "@").unwrap(),
                        CellState::Snake     => write!(&mut buf, "o").unwrap(),
                        CellState::Food      => write!(&mut buf, "$").unwrap(),
                        CellState::Free      => write!(&mut buf, " ").unwrap(),
                    }
                }
                write!(&mut buf, "|\n\r").unwrap();
            }
            for _ in 0..grid.grid_side() {
                write!(&mut buf, "-").unwrap();
            }

            String::from_utf8(buf.into_inner()).unwrap()
        }

    =}
}
