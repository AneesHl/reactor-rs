//! A snake minigame. Does not support windows.

target Rust {
    // LF-Rust programs integrate well with Cargo
    cargo-features: ["cli"],
    cargo-dependencies: {
        termcolor: "1",
        termion: "1", // (this doesn't support windows)
        rand: "0.8",
    },
    rust-include: "snakes.rs",
    keepalive: true,
};

// Import a shared reactor
import KeyboardEvents from "KeyboardEvents.lf";

// main reactor parameters can be set on the CLI, eg:
//  ./snake --main-grid-side 48
main reactor Snake(grid_side: usize(32), tempo_step: u32(40)) {
    preamble {=
        use crate::snakes::*;
        use crate::snakes;
        use termion::event::Key;
        use rand::prelude::*;

        const MAX_FOOD_ON_GRID: u32 = 2;
    =}

    /// this thing helps capturing key presses
    keyboard = new KeyboardEvents();

    /// Triggers a screen refresh, not a timer because we can
    /// shrink the period over time to speed up the game.
    logical action screen_refresh;
    /// The game speed level
    state tempo: u32(1);

    /// manually triggered
    logical action manually_add_more_food;
    /// periodic
    timer add_more_food(0, 5 sec);
    state food_on_grid: u32(0);

    state snake: CircularSnake ({= CircularSnake::new(grid_side) =});
    state grid: SnakeGrid ({= SnakeGrid::new(grid_side, &snake) =});

    /// Whither the snake has slithered last
    state snake_direction: Direction ({= Direction::RIGHT =});
    /// Changes with arrow key presses, might be invalid.
    /// Only committed to snake_direction on grid update.
    state pending_direction: Direction ({= Direction::RIGHT =});

    // @label startup
    reaction(startup) -> screen_refresh {=
        // KeyboardEvents makes stdout raw so this is safe
        snakes::output::paint_on_raw_console(&self.grid);
        // schedule the first one, then it reschedules itself.
        ctx.schedule(screen_refresh, After(Duration::from_secs(1)));
    =}

    // @label handle_key_press
    reaction(keyboard.arrow_key_pressed) {=
        // this might be overwritten several times, only committed on screen refreshes
        self.pending_direction = match ctx.get(keyboard__arrow_key_pressed).unwrap() {
            Key::Left => Direction::LEFT,
            Key::Right => Direction::RIGHT,
            Key::Up => Direction::UP,
            Key::Down => Direction::DOWN,
            _ => unreachable!(),
        };
    =}

    // @label refresh_screen
    reaction(screen_refresh) -> manually_add_more_food {=
        // check that the user's command is valid
        if self.pending_direction != self.snake_direction.opposite() {
            self.snake_direction = self.pending_direction;
        }

        // snakes don't "step" forward
        match self.snake.slither_forward(self.snake_direction, &mut self.grid) {
            UpdateResult::GameOver => { ctx.request_stop(Asap); return; },
            UpdateResult::FoodEaten => {
                self.food_on_grid -= 1;
                if self.food_on_grid == 0 {
                    ctx.schedule(manually_add_more_food, Asap);
                }
                self.tempo += 1;
            },
            UpdateResult::NothingInParticular => {/* do nothing in particular. */}
        }

        snakes::output::paint_on_raw_console(&self.grid);
    =}

    reaction(manually_add_more_food, add_more_food) {=
        if self.food_on_grid >= MAX_FOOD_ON_GRID {
            return; // there's enough food there
        }
        // find a random free cell that will become food
        let mut rng = thread_rng();
        loop {
            let row = rng.gen_range(0..params.grid_side);
            let col = rng.gen_range(0..params.grid_side);
            if self.grid[cell(row, col)] == CellState::Free {
                self.grid[cell(row, col)] = CellState::Food; // next screen update will catch this.
                self.food_on_grid += 1;
                break;
            }
            // otherwise try again
        }
    =}

    // @label schedule_next_tick
    reaction(screen_refresh) -> screen_refresh {=
        // select a delay depending on the tempo
        let millis = 400 - (params.tempo_step * self.tempo).min(300);
        let delay = Duration::from_millis(millis as u64);

        ctx.schedule(screen_refresh, After(delay));
    =}

}
