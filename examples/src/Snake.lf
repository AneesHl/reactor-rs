target Rust {
    cargo-features: ["cli"],
    cargo-dependencies: {
        termcolor: "1",
        termion: "1",
        rand: "0.8",
    },
    rust-include: "snakes.rs",
};

import KeyboardEvents from "KeyboardEvents.lf";

main reactor Snake(grid_side: usize(32), tempo: u8(2)) {
    preamble {=
        use snakes::*;
        use termion::event::Key;
    =}

    keyboard = new KeyboardEvents();

    /// Triggers a screen refresh, not a timer because we can
    /// shrink the period over time to speed up the game.
    logical action screen_refresh;

    state grid: SnakeGrid ({= SnakeGrid::new(grid_side) =});

    /// Whither the snake is currently looking
    state cur_heading: Direction ({= Direction::RIGHT =});

    reaction(keyboard.arrow_key_pressed) {=
        // change the current heading, might be overwritten between two frames
        self.cur_heading = match ctx.get(key_press).unwrap() {
            Key::Left => Side::LEFT,
            Key::Right => Side::RIGHT,
            Key::Up => Side::UP,
            Key::Down => Side::DOWN,
            _ => unreachable!(),
        };
    =}

    reaction(screen_refresh) {=
        if self.grid.step(self.cur_heading) {
            paint_on_raw_console(&self.grid);
        } else {
            // todo game over
        }
    =}

    reaction(startup) -> key_press {=
        self.maze.render_to_console(self.player_pos);

        let stdin = std::io::stdin();

        let key_press = key_press.clone();
        ctx.spawn_physical_thread(move |link| {
            use termion::input::TermRead;
            use termion::raw::IntoRawMode;

            // enter raw mode, to get key presses one by one
            // this will stay so until this variable is dropped
            let stdout = std::io::stdout().into_raw_mode().unwrap();

            for c in stdin.keys() {
                match c.unwrap() {
                    k@(Key::Left | Key::Right | Key::Up | Key::Down) => {
                        trace!("received {:?}", k);
                        link.schedule_physical_with_v(&key_press, Some(k), Asap).unwrap();
                    },
                    Key::Ctrl('c') => {
                        // todo request stop! for now just exit raw mode
                        drop(stdout);
                        break;
                    },
                    k => {
                        trace!("received {:?}", k);
                    }
                }
            }
        });
    =}


    preamble {=

        pub fn paint_on_raw_console(grid: &SnakeGrid) {
            use std::io::Write;
            let str = format_for_raw_console(grid);
            let stdout = std::io::stdout();
            let mut stdout = stdout.lock();

            // this escape char clears the terminal
            write!(stdout, "\x1B[2J{}", str).unwrap();
            stdout.flush().unwrap();
        }

        fn format_for_raw_console(grid: &SnakeGrid) -> String {
            use std::io::Write;
            use termcolor::{Buffer, BufferWriter, Color, ColorChoice, ColorSpec, WriteColor};

            let bufwtr = BufferWriter::stdout(ColorChoice::Always);
            let mut buf = bufwtr.buffer();

            for _ in 0..grid.grid_side() {
                write!(&mut buf, "-")
            }
            write!(&mut buf, "|\n\r");

            for row in 0..grid.grid_side() {
                write!(&mut buf, "|");
                for col in 0..grid.grid_side() {
                    match grid[cell(row, col)] {
                        CellState::Snake =>
                            if grid.snake.head() == cell(row, col) {
                                write!(&mut buf, "@");
                            } else {
                                write!(&mut buf, "o");
                            },
                        CellState::Food => write!(&mut buf, "$"),
                        CellState::Free => write!(&mut buf, " "),
                    }
                }
                write!(&mut buf, "|\n\r");
            }
            for _ in 0..grid.grid_side() {
                write!(&mut buf, "-")
            }

            String::from_utf8(buffer.into_inner()).unwrap()
        }

    =}
}
