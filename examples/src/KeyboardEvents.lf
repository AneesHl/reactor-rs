target Rust {
    cargo-dependencies: { termion: "1", }
};

/// Capture asynchronous key presses, and sends them through an output port.
/// Used by the other examples.
reactor KeyboardEvents {
    preamble {=
        use termion::event::Key;
    =}

    /// The latest key press.
    output arrow_key_pressed: Key;

    physical action key_press: Key;

    reaction(key_press) -> arrow_key_pressed {=
        ctx.set(arrow_key_pressed, ctx.get(key_press).unwrap());
    =}

    reaction(startup) -> key_press {=
        let stdin = std::io::stdin();

        let key_press = key_press.clone();
        ctx.spawn_physical_thread(move |link| {
            use termion::input::TermRead;
            use termion::raw::IntoRawMode;

            // enter raw mode, to get key presses one by one
            // this will stay so until this variable is dropped
            let stdout = std::io::stdout().into_raw_mode().unwrap();

            for c in stdin.keys() {
                match c.unwrap() {
                    k@(Key::Left | Key::Right | Key::Up | Key::Down) => {
                        trace!("received {:?}", k);
                        link.schedule_physical_with_v(&key_press, Some(k), Asap).ok();
                    },
                    Key::Ctrl('c') => {
                        drop(stdout);// exit raw mode
                        link.request_stop(Asap);
                        break;
                    },
                    k => {
                        trace!("received {:?}", k);
                    }
                }
            }
        });
    =}
}
