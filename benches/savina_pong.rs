/*
 * Copyright (c) 2021, TU Dresden.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#![allow(unused, non_snake_case, non_camel_case_types)]
#[macro_use]
extern crate reactor_rt;


use std::sync::{Arc, Mutex};

use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
use ::reactor_rt::Offset::{After, Asap};

use reactors::SavinaPongDispatcher;

use criterion::{BenchmarkId, Criterion, criterion_group, criterion_main, black_box};

use reactor_rt::*;

/*
The ping/pong game from Savina benchmarks. This can be compared
to the C implementation (see results.md).

See original at https://github.com/icyphy/lingua-franca/blob/f5868bec199e02f784393f32b594be5df935e2ee/benchmark/C/Savina/PingPong.lf


 */

criterion_group!(benches, reactor_main);
criterion_main!(benches);

fn reactor_main(c: &mut Criterion) {

    let mut group = c.benchmark_group("savina_pong");
    for num_pongs in [1000, 10_000, 50_000, 1_000_000].iter() {
        group.bench_with_input(
            BenchmarkId::from_parameter(num_pongs),
            num_pongs,
            |b, &size| {
                b.iter(|| {
                    let timeout = Some(Duration::from_secs(5));
                    launch(1, size, timeout);
                });
            }
        );
    }
    group.finish();
}

fn launch(numIterations: u32, count: u32, timeout: Option<Duration>)  {


    // todo CLI parsing
    let options = SchedulerOptions {
        timeout: None,
        keep_alive: false
    };
    let main_args = reactors::SavinaPongParams {
        count,
    };

    SyncScheduler::run_main::<reactors::SavinaPongDispatcher>(options, main_args);
}

//-------------------//
//---- REACTORS -----//
//-------------------//
mod reactors {
    pub use self::pong::PongDispatcher;
    pub use self::pong::PongParams;
    pub use self::ping::PingDispatcher;
    pub use self::ping::PingParams;
    pub use self::savina_pong::SavinaPongDispatcher;
    pub use self::savina_pong::SavinaPongParams;
    //--------------------------------------------//
    //------------ Pong -------//
    //-------------------//
    mod pong {
        //-- Generated by LFC @ 2021/07/26 16:15:18 --//
        #![allow(unused)]

        use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
        use ::reactor_rt::Offset::{After, Asap};
        use std::sync::{Arc, Mutex};



        // todo link to source
        pub struct Pong {
            count: u32,
        }

        #[warn(unused)]
        impl Pong {

            // --- reaction(receive) -> send {= ... =}
            fn react_0(&mut self,
                       #[allow(unused)] ctx: &mut ::reactor_rt::ReactionCtx,
                       #[allow(unused)] params: &PongParams,
                       receive: & ::reactor_rt::InputPort<u32>,
                       send: &mut ::reactor_rt::OutputPort<u32>) {
                self.count += 1;
                ctx.set(send, ctx.get(receive).unwrap());
            }

            // --- reaction(shutdown) {= ... =}
            fn react_1(&mut self,
                       #[allow(unused)] ctx: &mut ::reactor_rt::ReactionCtx,
                       #[allow(unused)] params: &PongParams,
            ) {
                if self.count != params.expected {
                    panic!("Pong expected to receive {} inputs, but it received {}.", params.expected, self.count);
                }
            }

        }

        /// Parameters for the construction of a [Pong]
        #[derive(Clone)]
        pub struct PongParams {
            pub expected: u32,
        }


        //------------------------//


        pub struct PongDispatcher {
            _id: ::reactor_rt::ReactorId,
            _impl: Pong,
            _params: PongParams,
            _startup_reactions: ::reactor_rt::ReactionSet,
            _shutdown_reactions: ::reactor_rt::ReactionSet,
            pub port_send: ::reactor_rt::OutputPort<u32>,
            pub port_receive: ::reactor_rt::InputPort<u32>,
        }

        impl PongDispatcher {
            #[inline]
            fn user_assemble(_id: ::reactor_rt::ReactorId, args: PongParams) -> Self {
                let PongParams { expected, } = args.clone();
                Self {
                    _id,
                    _params: args,
                    _startup_reactions: Default::default(),
                    _shutdown_reactions: Default::default(),
                    _impl: Pong {
                        count: 0,
                    },
                    port_send: Default::default(),
                    port_receive: Default::default(),
                }
            }
        }

        use ::reactor_rt::*; // after this point there's no user-written code

    impl ::reactor_rt::ReactorInitializer for PongDispatcher {
        type Wrapped = Pong;
        type Params = PongParams;
        const MAX_REACTION_ID: LocalReactionId = LocalReactionId::new_const(2);

        fn assemble(args: Self::Params, assembler: &mut AssemblyCtx) -> Self {
            // children reactors
            let () = {
                let PongParams { expected, } = args.clone();

                ()
            };

            // assemble self
            let mut _self = Self::user_assemble(assembler.get_next_id(), args);

            let react_0 = GlobalReactionId::new(_self.id(), LocalReactionId::new(0));
            let react_1 = GlobalReactionId::new(_self.id(), LocalReactionId::new(1));

            {
                _self._startup_reactions = vec![];
                _self._shutdown_reactions = vec![react_1,];

                _self.port_send.set_downstream(vec![].into());
                _self.port_receive.set_downstream(vec![react_0,].into());
            }
            {
                // Declare connections
            }


            _self
        }
    }


        impl ::reactor_rt::ReactorBehavior for PongDispatcher {

            #[inline]
            fn id(&self) -> ReactorId {
                self._id
            }

            fn react_erased(&mut self, ctx: &mut ::reactor_rt::ReactionCtx, rid: LocalReactionId) {
                match rid.index() {
                    0 => self._impl.react_0(ctx, &self._params, &self.port_receive, &mut self.port_send),
                    1 => self._impl.react_1(ctx, &self._params),

                    _ => panic!("Invalid reaction ID: {} should be < {}", rid, Self::MAX_REACTION_ID)
                }
            }

            fn cleanup_tag(&mut self, ctx: ::reactor_rt::ReactionCtx) {
                // todo
            }

            fn enqueue_startup(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._startup_reactions);

            }

            fn enqueue_shutdown(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._shutdown_reactions);
            }

        }
    }


    //--------------------------------------------//
    //------------ Ping -------//
    //-------------------//
    mod ping {
        //-- Generated by LFC @ 2021/07/26 16:15:18 --//
        #![allow(unused)]

        use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
        use ::reactor_rt::Offset::{After, Asap};
        use std::sync::{Arc, Mutex};



        // todo link to source
        pub struct Ping {
            pingsLeft: u32,
        }

        #[warn(unused)]
        impl Ping {

            // --- reaction(startup, serve) -> send {= ... =}
            fn react_0(&mut self,
                       #[allow(unused)] ctx: &mut ::reactor_rt::ReactionCtx,
                       #[allow(unused)] params: &PingParams,
                       #[allow(unused)] serve: & ::reactor_rt::LogicalAction::<()>,
                       send: &mut ::reactor_rt::OutputPort<u32>) {
                ctx.set(send, self.pingsLeft);
                self.pingsLeft -= 1;
            }

            // --- reaction (receive) -> serve {= ... =}
            fn react_1(&mut self,
                       #[allow(unused)] ctx: &mut ::reactor_rt::ReactionCtx,
                       #[allow(unused)] params: &PingParams,
                       _receive: & ::reactor_rt::InputPort<u32>,
                       #[allow(unused)] serve: & ::reactor_rt::LogicalAction::<()>) {
                if self.pingsLeft > 0 {
                    ctx.schedule(serve, Asap);
                } else {
                    ctx.request_stop();
                }
            }

        }

        /// Parameters for the construction of a [Ping]
        #[derive(Clone)]
        pub struct PingParams {
            pub count: u32,
        }


        //------------------------//


        pub struct PingDispatcher {
            _id: ::reactor_rt::ReactorId,
            _impl: Ping,
            _params: PingParams,
            _startup_reactions: ::reactor_rt::ReactionSet,
            _shutdown_reactions: ::reactor_rt::ReactionSet,
            pub port_send: ::reactor_rt::OutputPort<u32>,
            pub port_receive: ::reactor_rt::InputPort<u32>,
            action_serve: ::reactor_rt::LogicalAction::<()>,
        }

        impl PingDispatcher {
            #[inline]
            fn user_assemble(_id: ::reactor_rt::ReactorId, args: PingParams) -> Self {
                let PingParams { count, } = args.clone();
                Self {
                    _id,
                    _params: args,
                    _startup_reactions: Default::default(),
                    _shutdown_reactions: Default::default(),
                    _impl: Ping {
                        pingsLeft: count,
                    },
                    port_send: Default::default(),
                    port_receive: Default::default(),
                    action_serve: ::reactor_rt::LogicalAction::<()>::new("serve", None),
                }
            }
        }

        use ::reactor_rt::*; // after this point there's no user-written code

    impl ::reactor_rt::ReactorInitializer for PingDispatcher {
        type Wrapped = Ping;
        type Params = PingParams;
        const MAX_REACTION_ID: LocalReactionId = LocalReactionId::new_const(2);

        fn assemble(args: Self::Params, assembler: &mut AssemblyCtx) -> Self {
            // children reactors
            let () = {
                let PingParams { count, } = args.clone();

                ()
            };

            // assemble self
            let mut _self = Self::user_assemble(assembler.get_next_id(), args);

            let react_0 = GlobalReactionId::new(_self.id(), LocalReactionId::new(0));
            let react_1 = GlobalReactionId::new(_self.id(), LocalReactionId::new(1));

            {
                _self._startup_reactions = vec![react_0,];
                _self._shutdown_reactions = vec![];

                _self.port_send.set_downstream(vec![].into());
                _self.port_receive.set_downstream(vec![react_1,].into());
                _self.action_serve.set_downstream(vec![react_0,].into());
            }
            {
                // Declare connections
            }


            _self
        }
    }


        impl ::reactor_rt::ReactorBehavior for PingDispatcher {

            #[inline]
            fn id(&self) -> ReactorId {
                self._id
            }

            fn react_erased(&mut self, ctx: &mut ::reactor_rt::ReactionCtx, rid: LocalReactionId) {
                match rid.index() {
                    0 => self._impl.react_0(ctx, &self._params, &self.action_serve, &mut self.port_send),
                    1 => self._impl.react_1(ctx, &self._params, &self.port_receive, &self.action_serve),

                    _ => panic!("Invalid reaction ID: {} should be < {}", rid, Self::MAX_REACTION_ID)
                }
            }

            fn cleanup_tag(&mut self, ctx: ::reactor_rt::ReactionCtx) {
                // todo
            }

            fn enqueue_startup(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._startup_reactions);

            }

            fn enqueue_shutdown(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._shutdown_reactions);
            }

        }
    }


    //--------------------------------------------//
    //------------ SavinaPong -------//
    //-------------------//
    mod savina_pong {
        //-- Generated by LFC @ 2021/07/26 16:15:18 --//
        #![allow(unused)]

        use ::reactor_rt::{LogicalInstant, PhysicalInstant, Duration};
        use ::reactor_rt::Offset::{After, Asap};
        use std::sync::{Arc, Mutex};



        // todo link to source
        pub struct SavinaPong {

        }

        #[warn(unused)]
        impl SavinaPong {



        }

        /// Parameters for the construction of a [SavinaPong]
        #[derive(Clone)]
        pub struct SavinaPongParams {
            pub count: u32,
        }


        //------------------------//


        pub struct SavinaPongDispatcher {
            _id: ::reactor_rt::ReactorId,
            _impl: SavinaPong,
            _params: SavinaPongParams,
            _startup_reactions: ::reactor_rt::ReactionSet,
            _shutdown_reactions: ::reactor_rt::ReactionSet,

        }

        impl SavinaPongDispatcher {
            #[inline]
            fn user_assemble(_id: ::reactor_rt::ReactorId, args: SavinaPongParams) -> Self {
                let SavinaPongParams { count, } = args.clone();
                Self {
                    _id,
                    _params: args,
                    _startup_reactions: Default::default(),
                    _shutdown_reactions: Default::default(),
                    _impl: SavinaPong {

                    },

                }
            }
        }

        use ::reactor_rt::*; // after this point there's no user-written code

    impl ::reactor_rt::ReactorInitializer for SavinaPongDispatcher {
        type Wrapped = SavinaPong;
        type Params = SavinaPongParams;
        const MAX_REACTION_ID: LocalReactionId = LocalReactionId::new_const(0);

        fn assemble(args: Self::Params, assembler: &mut AssemblyCtx) -> Self {
            // children reactors
            let (mut ping, mut pong,) = {
                let SavinaPongParams { count, } = args.clone();
                // --- ping = new Ping(count=count);
                let ping: super::PingDispatcher = assembler.assemble_sub(super::PingParams { count, });
                // --- pong = new Pong(expected=count);
                let pong: super::PongDispatcher = assembler.assemble_sub(super::PongParams { expected: count, });
                (ping, pong,)
            };

            // assemble self
            let mut _self = Self::user_assemble(assembler.get_next_id(), args);



            {
                _self._startup_reactions = vec![];
                _self._shutdown_reactions = vec![];


            }
            {
                // Declare connections
                // --- ping.send -> pong.receive;
                bind_ports(&mut ping.port_send, &mut pong.port_receive);
                // --- pong.send -> ping.receive;
                bind_ports(&mut pong.port_send, &mut ping.port_receive);
            }
            assembler.register_reactor(ping);
            assembler.register_reactor(pong);

            _self
        }
    }


        impl ::reactor_rt::ReactorBehavior for SavinaPongDispatcher {

            #[inline]
            fn id(&self) -> ReactorId {
                self._id
            }

            fn react_erased(&mut self, ctx: &mut ::reactor_rt::ReactionCtx, rid: LocalReactionId) {
                match rid.index() {


                    _ => panic!("Invalid reaction ID: {} should be < {}", rid, Self::MAX_REACTION_ID)
                }
            }

            fn cleanup_tag(&mut self, ctx: ::reactor_rt::ReactionCtx) {
                // todo
            }

            fn enqueue_startup(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._startup_reactions);

            }

            fn enqueue_shutdown(&self, ctx: &mut StartupCtx) {
                ctx.enqueue(&self._shutdown_reactions);
            }

        }
    }
}
